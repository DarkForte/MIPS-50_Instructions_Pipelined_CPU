ori $16, $0, 1; $16应为1
ori $17, $0, 3; $17应为3
ori $8, $0, 1; $8应为1
lui $12, 1; $12应为65536
lui $13, 10; $13应为655360
start:addu $16, $16, $8; 这里应循环一次，第一次$16和$17均为2，第二次
subu $17,$17,$8; $16和$17不等，可以出去
beq $16, $17, start; 出去的时候，$16 = 3, $17 = 1
ori $8, $0,4; 这里测试内存读写，$8存储基地址
ori $9, $0, 4; $9存储地址步进
ori $10, $0, 8; $10辅助，循环一次
start2:sw $12, 0($8); 第1个字应该为65536
lw $14, 0($8); $14 = 65536
sw $13,4($8); 第2个字应该为655360
lw $15,4($8); $15 = 655360
sw $14, -4($8); 第0个字应该为65536
lw $18, -4($8); $18 = 65536
addu $8, $9, $8; 基地址前进1个字
beq $8, $10,start2; 应该循环一次
subu $8, $10, $8; 做减法，准备判断$10是否等于$8
beq $8, $0, end1; 不应该结束，$8 = 12, $10 = 8
lui $12, 65535; $12 = 0xFFFF0000
end1:ori $0, $0, 1;这里不应该写入
lui $8, 5;用lui指令复制
lui $9, 50;用lui指令复赋值
start3:addu $8, $9, $8;这四句必须全部正确
addu $9, $8, $9;否则，下面的第一句beq就不会执行
subu $9, $9, $8;第二句beq是一个死循环，就会报错
subu $8, $8, $9;
lui $10, 5;用于比较
beq $8, $10, start4;如果计算结果不正确，就不会调跳到start4
beq $0, $0, start3;不应该进入这里，这里是死循环

start4:ori $16, $0, 12;这一块的作用是用$18做中转，
ori $17, $0, 16;将之前内存中写的数据镜像再写一遍
lw $18, 0($16);最后只需要观察内存中的变量是否为0x10000, 0x10000, 0x10000,0xa0000,
sw $18, 0($17);0xa0000,0x10000,0x10000,0x10000即可
lw $18, -4($16);
sw $18, 4($17);
lw $18, -8($16);
sw $18, 8($17);
lw $18,-12($16);
sw $18, 12($17);










