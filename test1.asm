ori $16, $0, 1; $16应为1
ori $17, $0, 3; $17应为3
ori $8, $0, 1; $8应为1
lui $12, 1; $12应为65536
lui $13, 10; $13应为655360
start:addu $16, $16, $8; 这里应循环一次，第一次$16和$17均为2，第二次
subu $17,$17,$8; $16和$17不等，可以出去
beq $16, $17, start; 出去的时候，$16 = 3, $17 = 1
ori $8, $0,4; 这里测试内存读写，$8存储基地址
ori $9, $0, 4; $9存储地址步进
ori $10, $0, 8; $10辅助，循环一次
start2:sw $12, 0($8); 第1个字应该为65536
lw $14, 0($8); $14 = 65536
sw $13,4($8); 第2个字应该为655360
lw $15,4($8); $15 = 655360
sw $14, -4($8); 第0个字应该为65536
lw $18, -4($8); $18 = 65536
addu $8, $9, $8; 基地址前进1个字
beq $8, $10,start2; 应该循环一次
subu $8, $10, $8; 做减法，准备判断$10是否等于$8
beq $8, $0, end; 不应该结束，$8 = 12, $10 = 8
lui $12, 1111111111111111; $12 = 0xFFFF0000
end:


